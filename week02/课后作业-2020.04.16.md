# 每周总结可以写在这里

2020年04月16日  星期四  20:00


>Question 1： 计算机语言分类：
Answer 1:
  
>####**常见的几种分类**###

 1. 高级语言和低级语言
 2. 动态类型和静态类型
 3. 强制类型和弱类型
 4. 编译型，解释型，半编译半解释
 5. 面向对象型和面向过程型



----------

>**1. 高级语言和低级语言** ##
常见的低级语言有：机器码、汇编语言
高级语言常见如：c，c++，java，python，PHP，c#，Ruby，go，kotlin，swift。

    机器码：计算机能够直接识别的二级制编码，无论语言多高级都要转成二级制文件来让计算机识别运行。

    汇编：用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址，在不同的设备中有着不同的指令集

    高级语言：为省去编程时候的不必要的操作细节，节省代码量，可读性强，维护性强，更贴近人性化

    高级语言与低级语言的区别：高级语言大部分不能直接更硬件打交道，这使得相对来的程序运行速度降低，总之一句话来说那种语言更接近人性化的语言就更高级。


----------


>**2.动态类型和静态类型**##
动态性语言是指在程序运行期间才给变量指定数据的类型，常见于python和Ruby，而静态类型语言则恰好相反，在写程序代码的时候就要指定变量的类型，这种语言有：c，c++，java


----------


>**3.强制类型与弱类型**##

    我们可知C语言中，一个变量只能定义为一种类型，如float类型，那么它就只能是float类型而不能在不发生转化的情况下赋予int类型，这就是 **强制类型** 的具体体现。

    而python不是，python中的变量可以任意的复制，而没有类型的界限。这就是**弱类型**

    强制类型更严谨，更不容易出现错误，但弱类型的语言写起来更优雅，更舒畅


----------
>**4.  编译型，解释型，半编译半解释**##

    对于源程序，编译型语言在执行程序中会将源文件一次性的转化为机器码，而解释型语言是边编译边解释；
    编译型语言是离不开解释程序的，这也导致了解释性语言对于运行时候的速度比价慢，解释型语言只要有解释器，移植起来比较方便，而编译型语言则要对于不同的系统进行编译，是的工作繁琐，且在调试程序的时候比较慢

    编译型语言可见于c，c++等
    解释型语言可见于python，JavaScript，Perl，shell等

    而java是半编译半解释型的语言，java会将源文件在jVM中转化为字节码，即.class文件，在程序运行的时候转化为二进制文件。和C#中的.net有点区别，C#编译的成的.net目标代码，接近与二进制文件，可移植性没有java好，java是“一次编译，到处执行”，c#是“一次编码，到处编译”。


----------
>**5.  面向对象型和面向过程型**##

    面向过程是决定该怎么铺成一条路到达终点，而面向对象是要用那些具有特定功能的像来做，两者是不同的思想。
    c++是部部分面对对象的，java具有封装性是完全面对对象的，c语言是面对过程的语言





>Question 2：什么是递归函数？ 怎样实现递归？
Answer 2:  

    递归就是一个函数在它的函数体内调用它自身。执行递归函数将反复调用其自身，每调用一次就进入新的一层。递归函数必须有结束条件。 

    当函数在一直递推，直到遇到墙后返回e799bee5baa6e997aee7ad94e4b893e5b19e31333366303732，这个墙就是结束条件。 

    所以递归要有两个要素，结束条件与递推关系。

    递归有两个基本要素：
        （1）边界条件：确定递归到何时终止，也称为递归出口。

        （2）递归模式：大问题是如何分解为小问题的，也称为递归体。递归函数只有具备了这两个要素，才能在有限次计算后得出结果 

        在递归函数中，调用函数和被调用函数是同一个函数，需要注意的是递归函数的调用层次，如果把调用递归函数的主函数称为第0层，进入函数后，首次递归调用自身称为第1层调用；从第i层递归调用自身称为第i+1层。反之，退出第i+1层调用应该返回第i层。

        一个递归函数的调用过程类似于多个函数的嵌套的调用，只不过调用函数和被调用函数是同一个函数。为了保证递归函数的正确执行，系统需设立一个工作栈。具体地说，递归调用的内部执行过程如下：

        （1）运动开始时，首先为递归调用建立一个工作栈，其结构包括值参、局部变量和返回地址；

        （2）每次执行递归调用之前，把递归函数的值参和局部变量的当前值以及调用后的返回地址压栈；

        （3）每次递归调用结束后，将栈顶元


    扩展资料：

        递归就是某个函数直接或间接地调用了自身，这种调用方式叫做递归调用。说白了，还是函数调用。既然是函数调用，那么就有一个雷打不动的原则：所有被调用的函数都将创建一个副本，各自为调用者服务，而不受其他函数的影响。

        你的ff函数，递归多少次，就有多少个副本，再利用内存的栈式管理，反向退出。这个最好找一下“栈”这方面的东西看看，挺容易的，就像子弹匣一样，先进后出。

        从某种意义上说，这是不对的，因为就像刚才说的，一旦被调用，他将在内存中复制出一份代码，再被调用就再复制一份，换句话说，你可以吧同一个函数的多次调用理解称谓多个不同函数的一次调用，这样也会会简单些。

        再说=1和=0是为什么退出。递归，很需要注意的就是死递归，也就是说，某一个函数进入了无限调用自身的情况，永无止境地消耗内存等资源，这在编程方面是一大忌。

        但凡是递归的函数，一定会在某一个地方存在能够返回上一层函数的代码，否则必定死递归。ff函数中，那个else就是返回的出口，你可以这样想，如果没有那个if来进行判断，你递归到什么时候算完？ff是不是会一直调用自己。

        因为一旦某个函数A中调用了函数B（或者自己），那么A中的代码会停在调用的位置，而转向B中去执行，同理，如果B又调用函数C，那么B又停在调用的位置，去执行C，如果无限调用，那么程序是永远不会结束的。

        当然，也有这种情况，A调用B，然后继续自己的代码，不管B的死活，这种不在我们的讨论范围内，因为那牵扯到另一种编程方式：多线程。



----------
        
ECMA262学习笔记（一）

>Question1：怎样理解ECMAScript对象？

    Answer：ECMAScript对象是属性的集合，每个属性又有零个或者多个特性（如：writable）。属性是持有其他对象、原始值、函数的容器。原始值是一下内置类型之一的成员：Undefined、Null、Number、String、Boolean；对象是内置类型Object的成员；函数是可调用对象（也有的硕士可执行对象），方法是通过属性与对象关联的函数。

>Question2：为什么说ECMAScript是基于对象的？

    Answer：ECMAScript的基本语言和宿主设施都由对象提供，ECMAScript程序十一组可通信的对象。

>Question3：ECMAScript的内置对象（build-in Object）?

    Answer：全局对象、Object对象、Function对象、Array对象、Array对象、String对象、Boolean对象、Number对象、Math对象、Date对象、RegExp对象、JSON对象、Error对象。

>Question4：怎样理解原型链？

    Answer：每个构造器创建的对象，都有一个隐式的引用（_proto_，对象的原型），链接到构造器的“prototype“属性值，原型也可能有一个非空的隐式引用链接到自己的原型，以此类推，这叫做原型链。

Question5：JS中的相关术语的定义？

    Answer：

    （1）原始值：undefined、null、boolean、number、string类型之一的成员。原始值直接代表语言实现的最底层数据。

    （2）对象：对象是属性的集合，并有一个远行对象。原型可以是空值（Null）。

    （3）构造器：创建和初始化对象的函数对象。构造器的“prototype”属性值是一个原型对象，它用来实现继承和共享属性。

    （4）原型：为其他对象提供共享属性的对象。

    （5）原生对象：不是由宿主环境所定义而是由ECMAScript规范定义其语义的对象。一些原生对象是内置的，其他的可在ECMAScript程序执行过程中构建。

    （6）内置对象：有ECMAScript实现提供，独立于宿主环境的对象，ECMAScript程序开始执行时就存在。所有的内置对象都是原生对象。

    （7）宿主对象：有宿主环境提供的对象，用于完善ECMAScript执行环境。任何对象不是原生对象就是宿主对象。

    （8）未定义值：说明一个变量没有被分配值的一个原始值。（是一个原始值，用来说明一个变量没有被分配值！）

    （9）未定义类型：拥有唯一值“未定义值”的类型。

    （10）空值：代表对象值故意留空的一个原始值。

    （11）空类型：拥有唯一值“空值”的类型。

    （12）布尔值：布尔类型的成员，只有两个布尔值，true和false。

    （13）布尔类型：由原始值true和false组成的类型。

    （14）布尔对象：标准内置构造器Boolean的一个实例。通过new表达式，以一个布尔值作为参数调用Boolean构造器来创建布尔对象。由此产生的对象包含一个值为此布尔值的内部属性。一个Boolean对象可以强制转换为布尔值。

    （15）字符串值：原始值，他是零个或多个16位无符号呢整数组成的有限有序序列。

    （16）字符串类型：所有可能的字符串值的集合。

    （17）字符串对象：标准内置构造器String的一个实例。通过使用 new 表达式，以一个字符串值为参数调用 String 构造器来创建字符串对象。由此产生的对象包含一个值为此字符串值的内部属性。将 String 构造器作为一个函数来调用，可将一个字符串对象强制转换为一个字符串值。

    （18）数字值：原始值，对应一个64位双精度二进制IEEE754值。

    （19）数字类型：所有可能的数字值的集合，包括特殊的NaN值，正无穷，负无穷。

    （20）数字对象：标准内置构造器Number的一个实例。通过使用new表达式，以一个数字值作为参数调用Number构造器来创建数字对象。由此产生的对象包含和一个职位此数字值的内部属性。蒋Number构造器作为一个函数来调用，可将一个Number对象强制转换为一个数字值。

    （21）无穷：正无穷数字值。

    （22）NaN：not a number   值为IEEE 754“Not-a-Number”的数字值。

    （23）函数：标准内置构造器Function的一个实例，并且可作为子程序被调用。函数除了拥有命名的属性，还包含可执行代码、状态，用来确定被调用时的行为。函数的代码不限于 ECMAScript。

    （24）内置函数：作为函数的内置对象。如 parseInt 和 Math.floor()。

    （25）方法：作为属性值的函数。当一个函数被作为一个对象的方法调用，此对象将作为 this 值传递给函数。

    （26）内置方法：作为内置函数的方法。

    （27）继承属性：不是对象的自身属性，但是是对象原型的属性（原型的自身属性或继承属性）。
        


----------

ECMA262学习笔记（二）
Property特性：特性用于定义和解释命名属性的状态。


>ECMAScript建立执行环境：

    解释执行全局代码或使用eval函数输入的代码会创建并进入一个新的执行环境。每次调用ECMA脚本代码定义的函数也会建立并进入一个新的执行环境，即使函数是自身递归调用的。每一次return都会推出一个执行环境。

>ECMA脚本创建执行环境的过程：

    （1）将变量环境设置为全局环境。

    （2）将词法环境设置为全局环境。

    （3）将this绑定设置为全局对象。




>Question1：什么是产生式BNF？

Answer：

>BNF表示语法规则的方式为：

    1、非终结符用尖括号括起。
    2、每条规则的左部是一个非终结符，右部是由非终结符和终结符组成的一个符号串，中间一般以::=分开。
    3、具有相同左部的规则可以共用一个左部，各右部之间以直竖“|”隔开。

>BNF中常用的元字符及其表示的意义如下：

    1、在双引号中的字 "word" 代表着这些字符本身。而double_quote用来代表双引号；
    2、在双引号外的字（有可能有下划线）代表着语法部分；
    3、尖括号 < > 内包含的为必选项；
    4、方括号 [ ] 内包含的为可选项；
    5、大括号 { } 内包含的为可重复0至无数次的项；
    6、圆括号 ( ) 内包含的所有项为一组，用来控制表达式的优先级；
    7、竖线 | 表示在其左右两边任选一项，相当于"OR"的意思；
    8、::= 是“被定义为”的意思；
    9、...  表示术语符号；
    10、斜体字: 参数，在其它地方有解释；


>Question2：什么是四则运算？

Answer：

