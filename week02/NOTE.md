# 每周总结可以写在这里

2020年04月16日  星期四  20:00

课程主题：编程语言通识与JavaScript语言设计

知识点：

>1.编程语言通识：
  
      · 0型 无限 语言按语法分类
    （1）.非形式语言
          中文，英文
    （2）形式语言（乔姆斯基谱系）
         · 0型 无限制文法
         · 1型 上下文相关法
         · 2型 上下文无相关法
         · 3型 正则文法  （表达能力限制强）（词法：）


----------


  >·产生式（BNF）
    
    （1）用尖括号括起来的名称来表示语法结构名
    （2）语法结构分成基础结构和需要用其他语法结构定义的复合机构
         · 基础结构称终结符
         · 复合结构称非终结符
    （3）引号和中间的字符表示终结符
    （4）可以有括号
    （5）* 表示重复多次
    （6）| 表示“或”
    （7）+ 表示至少一次

    
----------

    
>四则运算：
      
      · 1 + 2 * 3
    终结符：
      · Number
      · + - * /
    非终结符：
      · MultiplicativeExpression
      · AddtiveExpression

  ·通过产生式理解乔姆斯基谱系
     
      · 0型 无限制文法
          · ?::=?
      · 1型 上下文相关文法
          · ?<A>?::=?<B>?
      · 2型 无限
          · <A>::=?
      · 3型 正则文法
          · <A>::=<A>?
          · <A>::=?<A> ×


>现代语言的特例


----------


>图灵完备性

      · 图灵完备性
      · 命令式-图灵机
            · goto
            · if 和 while
      · 声明式-lambda
            · 递归


----------


>动态与静态：

      · 动态
            · 在用户的设备/ 在线服务器上
            · 产品实际运行时
            · Runtime
      · 静态：
            · 在程序员的设备上
            · 产品开发时
            · Compiletime



----------


>类型系统：

      · 动态类型系统与静态类型系统
      · 强类型与弱类型
            · String + Number
            · String == Boolean
      · 复合类型
            · 结构体
            · 函数签名
      · 子类型
            · 逆变/协变



----------


>一般命令式编程语言：
      1、Atom

      2、Expression

      3、Statement

      4、Structure

      5、Program


----------


重学JavaScript
    语法  >  语义  >  进行时



    



练习：

>计算机语言分类：
    
####**常见的几种分类**###

      1. 高级语言和低级语言
      2. 动态类型和静态类型
      3. 强制类型和弱类型
      4. 编译型，解释型，半编译半解释
      5. 面向对象型和面向过程型



----------

>**1. 高级语言和低级语言** ##
      常见的低级语言有：机器码、汇编语言
      高级语言常见如：c，c++，java，python，PHP，c#，Ruby，go，kotlin，swift。

      机器码：计算机能够直接识别的二级制编码，无论语言多高级都要转成二级制文件来让计算机识别运行。

      汇编：用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址，在不同的设备中有着不同的指令集

      高级语言：为省去编程时候的不必要的操作细节，节省代码量，可读性强，维护性强，更贴近人性化

      高级语言与低级语言的区别：高级语言大部分不能直接更硬件打交道，这使得相对来的程序运行速度降低，总之一句话来说那种语言更接近人性化的语言就更高级。





>**2.动态类型和静态类型**##
      动态性语言是指在程序运行期间才给变量指定数据的类型，常见于python和Ruby，而静态类型语言则恰好相反，在写程序代码的时候就要指定变量的类型，这种语言有：c，c++，java



>**3.强制类型与弱类型**##

      我们可知C语言中，一个变量只能定义为一种类型，如float类型，那么它就只能是float类型而不能在不发生转化的情况下赋予int类型，这就是 **强制类型** 的具体体现。

      而python不是，python中的变量可以任意的复制，而没有类型的界限。这就是**弱类型**

      强制类型更严谨，更不容易出现错误，但弱类型的语言写起来更优雅，更舒畅



>**4.  编译型，解释型，半编译半解释**##

      对于源程序，编译型语言在执行程序中会将源文件一次性的转化为机器码，而解释型语言是边编译边解释；
      编译型语言是离不开解释程序的，这也导致了解释性语言对于运行时候的速度比价慢，解释型语言只要有解释器，移植起来比较方便，而编译型语言则要对于不同的系统进行编译，是的工作繁琐，且在调试程序的时候比较慢

      编译型语言可见于c，c++等
      解释型语言可见于python，JavaScript，Perl，shell等

      而java是半编译半解释型的语言，java会将源文件在jVM中转化为字节码，即.class文件，在程序运行的时候转化为二进制文件。和C#中的.net有点区别，C#编译的成的.net目标代码，接近与二进制文件，可移植性没有java好，java是“一次编译，到处执行”，c#是“一次编码，到处编译”。



>**5.  面向对象型和面向过程型**##

      面向过程是决定该怎么铺成一条路到达终点，而面向对象是要用那些具有特定功能的像来做，两者是不同的思想。
      c++是部部分面对对象的，java具有封装性是完全面对对象的，c语言是面对过程的语言



>正则表达式总结

      1.概念
            正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。
            正则表达式Reg是Javascript中的一个内置对象，和Array这些个类似，不需要第三方库什么的,可以在js中直接写

      2.创建方式

            构造函数形式创建

            let reg=new RegExp('正则内容','修饰符');

            正则内容可以是字符串或者正则正则表达式
            修饰符 包含属性 "g(global)"、"i(IgnoreCase忽略大小写)" 和 "m(Multiline多行)"，分别用于指定全局匹配、区分大小写的匹配和多行匹配。
            如果 正则内容是正则表达式，而不是字符串，则必须省略修饰符
            如果 正则内容不是合法的正则表达式，或 修饰符含有 "g"、"i" 和 "m" 之外的字符，抛出SyntaxError 异常。
            如果 正则内容是 正则表达式，但没有省略 attributes 参数，抛出TypeError 异常
            2 字面量形式

            let reg=/qux/igm;常用方式

            正则表达式可视化网址；

      4 正则的方法
            Reg.test();
            该方法用来测试某个字符串是否与正则匹配，匹配就返回true，否则返回false。该方法接受一个字符串作为参数

            Reg.compile();
            该方法的作用是能够对正则表达式进行编译，被编译过的正则在使用的时候效率会更高，适合于对一个正则多次调用的情况下，如果对一个正则只使用一两次，那么该方法没有特别显著的效应。
            参数为正则表达式，使其效率更高，也可以改变表达式
            Reg.exec()
            参数为字符串，返回数组
            返回数组的第 0 个元素是与正则表达式相匹配的文本
            第二个及后面的都是 正则中 小括号分组的匹配结果
            如果 正则表达式 没有分组 则只返回长度为1的数组
            该方法中的正则对象如果不是全局匹配，即没有g修饰符，则每次调用只会从字符串开头处匹配第一个结果，且每次调用结果都是一样的。
            只有指定为全局匹配，才能够按照从左往右依次去匹配，每次调用匹配一个结果，正则对象的lastIndex属性前进到本次匹配的末尾位置,下回再调用的时候，会从lastIndex处开始匹配而不是从头匹配


      5. 字符串的正则方法
            Str.search(参数);
            参数为 正则表达式 或者 子字符串
            返回 number类型的index值 说明第一次匹配到的位置，没匹配到返回-1。
            它返回的只是第一次匹配的位置
            Str.replace(参数1,参数2);
            该方法用来将字符串中的某些子串替换为需要的内容
            第一个参数可以为正则或者子字符串，表示匹配需要被替换的内容
            第二个参数为被替换的新的子字符串。
            如果声明为全局匹配则会替换所有结果，否则只替换第一个匹配到的结果。
            返回一个新的字符串，替换之后的字符串
            ...
            Str.match(参数);
            参数为 字符串或整则
            返回存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。
            返回数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本（和exec差不多）
            Str.split(参数1,可选参数2)；
            参数1 为字符串或正则表达式，从符合该表达式的地方开始分割，
            可选参数2 为 指定返回的数组的最大长度

      6.元字符
            正则表达式由两种基本字符类组成

            原义字符 就是表示原本意思的字符，比如 字符串abc匹配adc.
            元字符 就是表示不是原本意思的字符 比如 星号 * 匹配前面的子表达式零次或多次
            1 "." 查找单个字符
            2. "\w" word 查找单词字符如 a
            3. "\W" 查找非单词字符 如 ？
            4. "\d" digit 数字 如 2
            5. "\D" 非数字
            6. "\s" space 空格字符
            7. "\S" 非空白字符
            8. "'\b" 单词边界，如/\bm/ 匹配 "moon" 中的 'm'；在哪边 哪边不是单词
            9. "\B" 非单词边界

      7.方括号
            [abxds] 查找adxds中的任何一个字符
            [^abc] 查找任何不是abc的字符
            [0-9] [a-z] 查找范围
            [red|green|blue] 查找红或绿或蓝
            8.量词
            n+: 匹配任何包含 至少一个n 的字符串

            n*: 匹配任何包含 零个或多个 n 的字符串。

            n?: 匹配任何包含 零个或一个 n 的字符串。

            n{x}: 匹配包含 X 个 n 的序列 的字符串。

            n{x,y}: 匹配包含 X 至 Y 个 n 的序列的字符串。

            n{x,}: 匹配包含 至少 X 个 n 的序列的字符串。

            n$: 匹配 任何结尾为 n 的字符串。

            ^n: 匹配 任何开头为 n 的字符串。

            ?=n : 匹配 任何其后紧接n 的字符串。

            ?!n: 匹配 任何其后没有紧接n 的字符串。




